{{> header}}

#include "im-encoder.h"

#include <app/util/basic-types.h>
#include <app/CommandHandler.h>
#include <app/CommandSender.h>
#include <app/InteractionModelEngine.h>
#include <support/ErrorStr.h>
#include <support/ReturnMacros.h>
#include <support/logging/CHIPLogging.h>

namespace chip {
namespace app {
namespace cluster {

{{#chip_server_clusters}}

namespace {{asCamelCased name false}} {

{{> cluster_header}}

{{#chip_server_cluster_commands}}
CHIP_ERROR Encode{{asType name}}Command(chip::app::Command * ZCLcommand, chip::EndpointId ZCLendpointId, chip::GroupId ZCLgroupId{{#chip_server_cluster_command_arguments}}, const {{chipType}} {{asCamelCased label}}{{#if (isByteString type)}}, uint32_t {{asCamelCased label}}_Len{{/if}}{{/chip_server_cluster_command_arguments}})
{
    Command::CommandParams cmdParams = { ZCLendpointId, ZCLgroupId, {{asCamelCased clusterName false}}::kClusterId, {{asCamelCased clusterName false}}::k{{asCamelCased name false}}CommandId,
                                         (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    TLV::TLVWriter writer  = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;

    uint8_t argSeqNumber = 0;
    (void)argSeqNumber;

    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));
{{#chip_server_cluster_command_arguments}}
    // {{asCamelCased label}}: {{asCamelCased type}}
{{#if (isByteString type)}}
    ReturnErrorOnFailure(writer.PutBytes(TLV::ContextTag(argSeqNumber++), {{asCamelCased label}}, {{asCamelCased label}}_Len));
{{else if (isString type)}}
    ReturnErrorOnFailure(writer.PutString(TLV::ContextTag(argSeqNumber++), {{asCamelCased label}}));
{{else}}
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), {{asCamelCased label}}));
{{/if}}
{{/chip_server_cluster_command_arguments}}
    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return CHIP_NO_ERROR;
}

{{/chip_server_cluster_commands}}

void InitCluster(chip::app::InteractionModelEngine * ime)
{
{{#chip_server_cluster_commands}}
    ime->RegisterClusterCommandHandler(
        {{asCamelCased clusterName false}}::kClusterId,
        {{asCamelCased clusterName false}}::k{{asCamelCased name false}}CommandId,
        Command::CommandRoleId::kCommandHandlerId,
        Handle{{asType name}}CommandReceived
        );
{{/chip_server_cluster_commands}}
}

void ShutdownCluster(chip::app::InteractionModelEngine * ime)
{
{{#chip_server_cluster_commands}}
    ime->DeregisterClusterCommandHandler(
        {{asCamelCased clusterName false}}::kClusterId,
        {{asCamelCased clusterName false}}::k{{asCamelCased name false}}CommandId,
        Command::CommandRoleId::kCommandHandlerId
        );
{{/chip_server_cluster_commands}}
}

} // namespace {{asCamelCased name false}}

{{/chip_server_clusters}}

void InitClusters(chip::app::InteractionModelEngine * ime)
{
{{#chip_server_clusters}}
    {{asCamelCased name false}}::InitCluster(ime);
{{/chip_server_clusters}}
}

void ShutdownClusters(chip::app::InteractionModelEngine * ime)
{
{{#chip_server_clusters}}
    {{asCamelCased name false}}::ShutdownCluster(ime);
{{/chip_server_clusters}}
}

} // namespace cluster
} // namespace app
} // namespace chip
