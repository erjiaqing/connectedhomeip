{{> header}}

#include <core/CHIPCore.h>

#include <app/CommandSender.h>
#include <app/InteractionModelEngine.h>
#include <app/im-encoder.h>

#include <controller/CHIPClusters.h>
#include <controller/CHIPDevice.h>
#include <controller/CHIPDeviceController_deprecated.h>

using namespace chip;
using namespace chip::app;

namespace chip {
namespace app {
CommandSender * GetCommandSender();
namespace cluster {

// Empty command handlers
{{#chip_server_clusters}}
namespace {{asCamelCased name false}} {
{{#chip_server_cluster_commands}}
void Handle{{asType name}}CommandReceived(chip::TLV::TLVReader & aReader, chip::app::Command * apCommandObj) {}
{{/chip_server_cluster_commands}}
} // namespace {{asCamelCased name false}}

{{/chip_server_clusters}}
} // namespace cluster
} // namespace app
} // namespace chip

extern "C" {

{{#chip_server_clusters}}
// Cluster {{asCamelCased name false}}
{{#chip_server_cluster_commands}}
CHIP_ERROR chip_ime_AppendCommand_{{asCamelCased clusterName false}}_{{asCamelCased name false}}(chip::Controller::Device * device, chip::EndpointId ZCLendpointId, chip::GroupId ZCLgroupId{{#chip_server_cluster_command_arguments}}, {{chipType}} {{asCamelCased label}}{{#if (isByteString type)}}, uint32_t {{asCamelCased label}}_Len{{/if}}{{/chip_server_cluster_command_arguments}})
{
    if (device == nullptr)
    {
        return CHIP_ERROR_INCORRECT_STATE;
    }
    chip::Controller::{{asCamelCased clusterName false}}Cluster cluster{{asCamelCased clusterName false}};
    (void) ZCLgroupId;
    cluster{{asCamelCased clusterName false}}.Associate(device, ZCLendpointId);
    return cluster{{asCamelCased clusterName false}}.{{asCamelCased name false}}(nullptr{{#chip_server_cluster_command_arguments}}, {{asCamelCased label}}{{/chip_server_cluster_command_arguments}});
}
{{/chip_server_cluster_commands}}
// End of Cluster {{asCamelCased name false}}

{{/chip_server_clusters}}

}
