/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#include "af-structs.h"
#include "enums.h"
#include <app/util/basic-types.h>
#include <core/CHIPSafeCasts.h>
#include <core/CHIPTLV.h>
#include <stdint.h>
#include <support/CodeUtils.h>
#include <support/Span.h>
#include <support/logging/CHIPLogging.h>

// TODO: This still not resolves issue for lists inside struct, however, it resolves lists of structs.

using namespace chip;

// Struct for ApplicationLauncherApp
CHIP_ERROR EncodeStruct(const _ApplicationLauncherApp & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.catalogVendorId));
    SuccessOrExit(err = writer.PutString(TLV::ContextTag(seq++), chip::Uint8::to_const_char(val.applicationId)));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_ApplicationLauncherApp & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.catalogVendorId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.GetDataPtr(aVal.applicationId));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for AudioOutputInfo
CHIP_ERROR EncodeStruct(const _AudioOutputInfo & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.index));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.outputType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.name));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_AudioOutputInfo & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.index));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.outputType));
            break;
        }
        case 2: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                aVal.name = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for BasicCommissioningInfoType
CHIP_ERROR EncodeStruct(const _BasicCommissioningInfoType & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.FailSafeExpiryLengthMs));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_BasicCommissioningInfoType & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.FailSafeExpiryLengthMs));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for ConfigureReportingRecord
CHIP_ERROR EncodeStruct(const _ConfigureReportingRecord & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.direction));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.minimumReportingInterval));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.maximumReportingInterval));
    SuccessOrExit(err = writer.PutNull(TLV::ContextTag(seq++)));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.timeoutPeriod));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_ConfigureReportingRecord & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.direction));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.attributeId));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(aVal.attributeType));
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(aVal.minimumReportingInterval));
            break;
        }
        case 4: {
            ReturnErrorOnFailure(reader.Get(aVal.maximumReportingInterval));
            break;
        }
        case 5: {
            // Nothing;
            break;
        }
        case 6: {
            ReturnErrorOnFailure(reader.Get(aVal.timeoutPeriod));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for ConfigureReportingStatusRecord
CHIP_ERROR EncodeStruct(const _ConfigureReportingStatusRecord & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.status));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.direction));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeId));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_ConfigureReportingStatusRecord & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.status));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.direction));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(aVal.attributeId));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for ContentLaunchAdditionalInfo
CHIP_ERROR EncodeStruct(const _ContentLaunchAdditionalInfo & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.PutString(TLV::ContextTag(seq++), chip::Uint8::to_const_char(val.name)));
    SuccessOrExit(err = writer.PutString(TLV::ContextTag(seq++), chip::Uint8::to_const_char(val.value)));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_ContentLaunchAdditionalInfo & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.GetDataPtr(aVal.name));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.GetDataPtr(aVal.value));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for ContentLaunchBrandingInformation
CHIP_ERROR EncodeStruct(const _ContentLaunchBrandingInformation & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.PutString(TLV::ContextTag(seq++), chip::Uint8::to_const_char(val.providerName)));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.background));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.logo));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.progressBar));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.splash));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.waterMark));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_ContentLaunchBrandingInformation & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.GetDataPtr(aVal.providerName));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.background));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(aVal.logo));
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(aVal.progressBar));
            break;
        }
        case 4: {
            ReturnErrorOnFailure(reader.Get(aVal.splash));
            break;
        }
        case 5: {
            ReturnErrorOnFailure(reader.Get(aVal.waterMark));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for ContentLaunchDimension
CHIP_ERROR EncodeStruct(const _ContentLaunchDimension & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.PutString(TLV::ContextTag(seq++), chip::Uint8::to_const_char(val.width)));
    SuccessOrExit(err = writer.PutString(TLV::ContextTag(seq++), chip::Uint8::to_const_char(val.height)));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.metric));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_ContentLaunchDimension & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.GetDataPtr(aVal.width));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.GetDataPtr(aVal.height));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(aVal.metric));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for ContentLaunchParamater
CHIP_ERROR EncodeStruct(const _ContentLaunchParamater & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.Type));
    SuccessOrExit(err = writer.PutString(TLV::ContextTag(seq++), chip::Uint8::to_const_char(val.Value)));
    SuccessOrExit(err = writer.PutNull(TLV::ContextTag(seq++)) /* TODO: List inside struct is not implemented. */
    );
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_ContentLaunchParamater & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.Type));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.GetDataPtr(aVal.Value));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.GetDataPtr(aVal.ExternalIDList));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for ContentLaunchStyleInformation
CHIP_ERROR EncodeStruct(const _ContentLaunchStyleInformation & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.PutString(TLV::ContextTag(seq++), chip::Uint8::to_const_char(val.imageUrl)));
    SuccessOrExit(err = writer.PutString(TLV::ContextTag(seq++), chip::Uint8::to_const_char(val.color)));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.size));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_ContentLaunchStyleInformation & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.GetDataPtr(aVal.imageUrl));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.GetDataPtr(aVal.color));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(aVal.size));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for DeviceType
CHIP_ERROR EncodeStruct(const _DeviceType & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.type));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.revision));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_DeviceType & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.type));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.revision));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for DiscoverAttributesInfoRecord
CHIP_ERROR EncodeStruct(const _DiscoverAttributesInfoRecord & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeType));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_DiscoverAttributesInfoRecord & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.attributeId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.attributeType));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for ExtendedDiscoverAttributesInfoRecord
CHIP_ERROR EncodeStruct(const _ExtendedDiscoverAttributesInfoRecord & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeAccessControl));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_ExtendedDiscoverAttributesInfoRecord & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.attributeId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.attributeType));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(aVal.attributeAccessControl));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for FabricDescriptor
CHIP_ERROR EncodeStruct(const _FabricDescriptor & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.FabricId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.VendorId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.NodeId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.Label));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_FabricDescriptor & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.FabricId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.VendorId));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(aVal.NodeId));
            break;
        }
        case 3: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                aVal.Label = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for GroupKey
CHIP_ERROR EncodeStruct(const _GroupKey & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.VendorId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.GroupKeyIndex));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.GroupKeyRoot));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.GroupKeyEpochStartTime));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.GroupKeySecurityPolicy));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_GroupKey & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.VendorId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.GroupKeyIndex));
            break;
        }
        case 2: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                aVal.GroupKeyRoot = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(aVal.GroupKeyEpochStartTime));
            break;
        }
        case 4: {
            ReturnErrorOnFailure(reader.Get(aVal.GroupKeySecurityPolicy));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for GroupState
CHIP_ERROR EncodeStruct(const _GroupState & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.VendorId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.VendorGroupId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.GroupKeySetIndex));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_GroupState & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.VendorId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.VendorGroupId));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(aVal.GroupKeySetIndex));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for IasAceZoneStatusResult
CHIP_ERROR EncodeStruct(const _IasAceZoneStatusResult & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.zoneId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.zoneStatus));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_IasAceZoneStatusResult & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.zoneId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.zoneStatus));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for LabelStruct
CHIP_ERROR EncodeStruct(const _LabelStruct & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.label));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.value));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_LabelStruct & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                aVal.label = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        case 1: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                aVal.value = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for MediaInputInfo
CHIP_ERROR EncodeStruct(const _MediaInputInfo & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.index));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.inputType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.name));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.description));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_MediaInputInfo & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.index));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.inputType));
            break;
        }
        case 2: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                aVal.name = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        case 3: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                aVal.description = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for MediaPlaybackPosition
CHIP_ERROR EncodeStruct(const _MediaPlaybackPosition & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.updatedAt));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.position));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_MediaPlaybackPosition & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.updatedAt));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.position));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for NavigateTargetTargetInfo
CHIP_ERROR EncodeStruct(const _NavigateTargetTargetInfo & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.identifier));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.name));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_NavigateTargetTargetInfo & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.identifier));
            break;
        }
        case 1: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                aVal.name = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for NeighborTable
CHIP_ERROR EncodeStruct(const _NeighborTable & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.ExtAddress));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.Age));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.Rloc16));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.LinkFrameCounter));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.MleFrameCounter));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.LQI));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.AverageRssi));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.LastRssi));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.FrameErrorRate));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.MessageErrorRate));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.RxOnWhenIdle));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.FullThreadDevice));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.FullNetworkData));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.IsChild));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_NeighborTable & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.ExtAddress));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.Age));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(aVal.Rloc16));
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(aVal.LinkFrameCounter));
            break;
        }
        case 4: {
            ReturnErrorOnFailure(reader.Get(aVal.MleFrameCounter));
            break;
        }
        case 5: {
            ReturnErrorOnFailure(reader.Get(aVal.LQI));
            break;
        }
        case 6: {
            ReturnErrorOnFailure(reader.Get(aVal.AverageRssi));
            break;
        }
        case 7: {
            ReturnErrorOnFailure(reader.Get(aVal.LastRssi));
            break;
        }
        case 8: {
            ReturnErrorOnFailure(reader.Get(aVal.FrameErrorRate));
            break;
        }
        case 9: {
            ReturnErrorOnFailure(reader.Get(aVal.MessageErrorRate));
            break;
        }
        case 10: {
            ReturnErrorOnFailure(reader.Get(aVal.RxOnWhenIdle));
            break;
        }
        case 11: {
            ReturnErrorOnFailure(reader.Get(aVal.FullThreadDevice));
            break;
        }
        case 12: {
            ReturnErrorOnFailure(reader.Get(aVal.FullNetworkData));
            break;
        }
        case 13: {
            ReturnErrorOnFailure(reader.Get(aVal.IsChild));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for NetworkInterfaceType
CHIP_ERROR EncodeStruct(const _NetworkInterfaceType & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.Name));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.FabricConnected));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.OffPremiseServicesReachableIPv4));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.OffPremiseServicesReachableIPv6));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.HardwareAddress));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.Type));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_NetworkInterfaceType & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                aVal.Name = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.FabricConnected));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(aVal.OffPremiseServicesReachableIPv4));
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(aVal.OffPremiseServicesReachableIPv6));
            break;
        }
        case 4: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                aVal.HardwareAddress = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        case 5: {
            ReturnErrorOnFailure(reader.Get(aVal.Type));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for Notification
CHIP_ERROR EncodeStruct(const _Notification & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.contentId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.statusFeedback));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_Notification & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.contentId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.statusFeedback));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for OperationalDatasetComponents
CHIP_ERROR EncodeStruct(const _OperationalDatasetComponents & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.ActiveTimestampPresent));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.PendingTimestampPresent));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.MasterKeyPresent));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.NetworkNamePresent));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.ExtendedPanIdPresent));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.MeshLocalPrefixPresent));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.DelayPresent));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.PanIdPresent));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.ChannelPresent));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.PskcPresent));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.SecurityPolicyPresent));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.ChannelMaskPresent));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_OperationalDatasetComponents & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.ActiveTimestampPresent));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.PendingTimestampPresent));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(aVal.MasterKeyPresent));
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(aVal.NetworkNamePresent));
            break;
        }
        case 4: {
            ReturnErrorOnFailure(reader.Get(aVal.ExtendedPanIdPresent));
            break;
        }
        case 5: {
            ReturnErrorOnFailure(reader.Get(aVal.MeshLocalPrefixPresent));
            break;
        }
        case 6: {
            ReturnErrorOnFailure(reader.Get(aVal.DelayPresent));
            break;
        }
        case 7: {
            ReturnErrorOnFailure(reader.Get(aVal.PanIdPresent));
            break;
        }
        case 8: {
            ReturnErrorOnFailure(reader.Get(aVal.ChannelPresent));
            break;
        }
        case 9: {
            ReturnErrorOnFailure(reader.Get(aVal.PskcPresent));
            break;
        }
        case 10: {
            ReturnErrorOnFailure(reader.Get(aVal.SecurityPolicyPresent));
            break;
        }
        case 11: {
            ReturnErrorOnFailure(reader.Get(aVal.ChannelMaskPresent));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for PowerProfileRecord
CHIP_ERROR EncodeStruct(const _PowerProfileRecord & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.powerProfileId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.energyPhaseId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.powerProfileRemoteControl));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.powerProfileState));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_PowerProfileRecord & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.powerProfileId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.energyPhaseId));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(aVal.powerProfileRemoteControl));
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(aVal.powerProfileState));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for ReadAttributeStatusRecord
CHIP_ERROR EncodeStruct(const _ReadAttributeStatusRecord & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.status));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeType));
    SuccessOrExit(err = writer.PutNull(TLV::ContextTag(seq++)));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_ReadAttributeStatusRecord & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.attributeId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.status));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(aVal.attributeType));
            break;
        }
        case 3: {
            // Nothing;
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for ReadReportingConfigurationAttributeRecord
CHIP_ERROR EncodeStruct(const _ReadReportingConfigurationAttributeRecord & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.direction));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeId));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_ReadReportingConfigurationAttributeRecord & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.direction));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.attributeId));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for ReadReportingConfigurationRecord
CHIP_ERROR EncodeStruct(const _ReadReportingConfigurationRecord & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.status));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.direction));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.minimumReportingInterval));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.maximumReportingInterval));
    SuccessOrExit(err = writer.PutNull(TLV::ContextTag(seq++)));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.timeoutPeriod));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_ReadReportingConfigurationRecord & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.status));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.direction));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(aVal.attributeId));
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(aVal.attributeType));
            break;
        }
        case 4: {
            ReturnErrorOnFailure(reader.Get(aVal.minimumReportingInterval));
            break;
        }
        case 5: {
            ReturnErrorOnFailure(reader.Get(aVal.maximumReportingInterval));
            break;
        }
        case 6: {
            // Nothing;
            break;
        }
        case 7: {
            ReturnErrorOnFailure(reader.Get(aVal.timeoutPeriod));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for ReadStructuredAttributeRecord
CHIP_ERROR EncodeStruct(const _ReadStructuredAttributeRecord & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.indicator));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.indicies));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_ReadStructuredAttributeRecord & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.attributeId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.indicator));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(aVal.indicies));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for ReportAttributeRecord
CHIP_ERROR EncodeStruct(const _ReportAttributeRecord & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeType));
    SuccessOrExit(err = writer.PutNull(TLV::ContextTag(seq++)));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_ReportAttributeRecord & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.attributeId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.attributeType));
            break;
        }
        case 2: {
            // Nothing;
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for RouteTable
CHIP_ERROR EncodeStruct(const _RouteTable & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.ExtAddress));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.Rloc16));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.RouterId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.NextHop));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.PathCost));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.LQIIn));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.LQIOut));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.Age));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.Allocated));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.LinkEstablished));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_RouteTable & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.ExtAddress));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.Rloc16));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(aVal.RouterId));
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(aVal.NextHop));
            break;
        }
        case 4: {
            ReturnErrorOnFailure(reader.Get(aVal.PathCost));
            break;
        }
        case 5: {
            ReturnErrorOnFailure(reader.Get(aVal.LQIIn));
            break;
        }
        case 6: {
            ReturnErrorOnFailure(reader.Get(aVal.LQIOut));
            break;
        }
        case 7: {
            ReturnErrorOnFailure(reader.Get(aVal.Age));
            break;
        }
        case 8: {
            ReturnErrorOnFailure(reader.Get(aVal.Allocated));
            break;
        }
        case 9: {
            ReturnErrorOnFailure(reader.Get(aVal.LinkEstablished));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for SceneExtensionAttributeInfo
CHIP_ERROR EncodeStruct(const _SceneExtensionAttributeInfo & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeType));
    SuccessOrExit(err = writer.PutNull(TLV::ContextTag(seq++)));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_SceneExtensionAttributeInfo & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.attributeType));
            break;
        }
        case 1: {
            // Nothing;
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for SceneExtensionFieldSet
CHIP_ERROR EncodeStruct(const _SceneExtensionFieldSet & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.clusterId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.length));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.value));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_SceneExtensionFieldSet & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.clusterId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.length));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(aVal.value));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for ScheduledPhase
CHIP_ERROR EncodeStruct(const _ScheduledPhase & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.energyPhaseId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.scheduledTime));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_ScheduledPhase & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.energyPhaseId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.scheduledTime));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for SecurityPolicy
CHIP_ERROR EncodeStruct(const _SecurityPolicy & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.RotationTime));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.Flags));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_SecurityPolicy & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.RotationTime));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.Flags));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for TestListStructOctet
CHIP_ERROR EncodeStruct(const _TestListStructOctet & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.fabricIndex));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.operationalCert));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_TestListStructOctet & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.fabricIndex));
            break;
        }
        case 1: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                aVal.operationalCert = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for ThreadInterfaceScanResult
CHIP_ERROR EncodeStruct(const _ThreadInterfaceScanResult & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.DiscoveryResponse));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_ThreadInterfaceScanResult & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                aVal.DiscoveryResponse = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for ThreadMetrics
CHIP_ERROR EncodeStruct(const _ThreadMetrics & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.Id));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.Name));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.StackFreeCurrent));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.StackFreeMinimum));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.StackSize));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_ThreadMetrics & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.Id));
            break;
        }
        case 1: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                aVal.Name = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(aVal.StackFreeCurrent));
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(aVal.StackFreeMinimum));
            break;
        }
        case 4: {
            ReturnErrorOnFailure(reader.Get(aVal.StackSize));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for TransferredPhase
CHIP_ERROR EncodeStruct(const _TransferredPhase & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.energyPhaseId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.macroPhaseId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.expectedDuration));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.peakPower));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.energy));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.maxActivationDelay));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_TransferredPhase & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.energyPhaseId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.macroPhaseId));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(aVal.expectedDuration));
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(aVal.peakPower));
            break;
        }
        case 4: {
            ReturnErrorOnFailure(reader.Get(aVal.energy));
            break;
        }
        case 5: {
            ReturnErrorOnFailure(reader.Get(aVal.maxActivationDelay));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for TvChannelInfo
CHIP_ERROR EncodeStruct(const _TvChannelInfo & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.majorNumber));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.minorNumber));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.name));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.callSign));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.affiliateCallSign));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_TvChannelInfo & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.majorNumber));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.minorNumber));
            break;
        }
        case 2: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                aVal.name = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        case 3: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                aVal.callSign = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        case 4: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                aVal.affiliateCallSign = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for TvChannelLineupInfo
CHIP_ERROR EncodeStruct(const _TvChannelLineupInfo & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.PutString(TLV::ContextTag(seq++), chip::Uint8::to_const_char(val.operatorName)));
    SuccessOrExit(err = writer.PutString(TLV::ContextTag(seq++), chip::Uint8::to_const_char(val.lineupName)));
    SuccessOrExit(err = writer.PutString(TLV::ContextTag(seq++), chip::Uint8::to_const_char(val.postalCode)));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.lineupInfoType));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_TvChannelLineupInfo & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.GetDataPtr(aVal.operatorName));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.GetDataPtr(aVal.lineupName));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.GetDataPtr(aVal.postalCode));
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(aVal.lineupInfoType));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for WiFiInterfaceScanResult
CHIP_ERROR EncodeStruct(const _WiFiInterfaceScanResult & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.Security));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.SSID));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.BSSID));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.Channel));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.FrequencyBand));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_WiFiInterfaceScanResult & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.Security));
            break;
        }
        case 1: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                aVal.SSID = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        case 2: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                aVal.BSSID = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(aVal.Channel));
            break;
        }
        case 4: {
            ReturnErrorOnFailure(reader.Get(aVal.FrequencyBand));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for WriteAttributeRecord
CHIP_ERROR EncodeStruct(const _WriteAttributeRecord & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeType));
    SuccessOrExit(err = writer.PutNull(TLV::ContextTag(seq++)));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_WriteAttributeRecord & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.attributeId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.attributeType));
            break;
        }
        case 2: {
            // Nothing;
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for WriteAttributeStatusRecord
CHIP_ERROR EncodeStruct(const _WriteAttributeStatusRecord & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.status));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeId));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_WriteAttributeStatusRecord & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.status));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.attributeId));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for WriteStructuredAttributeRecord
CHIP_ERROR EncodeStruct(const _WriteStructuredAttributeRecord & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.indicator));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.indicies));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeType));
    SuccessOrExit(err = writer.PutNull(TLV::ContextTag(seq++)));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_WriteStructuredAttributeRecord & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.attributeId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.indicator));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(aVal.indicies));
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(aVal.attributeType));
            break;
        }
        case 4: {
            // Nothing;
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

// Struct for WriteStructuredAttributeStatusRecord
CHIP_ERROR EncodeStruct(const _WriteStructuredAttributeStatusRecord & val, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.status));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.indicator));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.indicies));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR DecodeStruct(_WriteStructuredAttributeStatusRecord & aVal, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(aVal.status));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(aVal.attributeId));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(aVal.indicator));
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(aVal.indicies));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}
