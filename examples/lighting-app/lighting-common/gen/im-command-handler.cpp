#include "im-command-handler.h"

#include <cinttypes>

#include <app/Command.h>
#include <core/CHIPCore.h>
#include <core/CHIPError.h>
#include <core/CHIPTLV.h>

#include "cluster-id.h"
#include "command-id.h"

// TODO: This file shoule be generated by ZAP

namespace chip {
namespace app {
namespace cluster {
namespace NetworkProvisioning {

CHIP_ERROR ProcessServerSideAddWiFiNetworkCommand(chip::EndpointId aEndPointId, chip::TLV::TLVReader & aReader,
                                                  Command * apCommandObj)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    const uint8_t * ssid;
    uint32_t ssidLen;
    const uint8_t * credentials;
    uint32_t credentialsLen;
    uint64_t breadcrumb;
    uint32_t timeoutMs;

    while ((err = aReader.Next()) == CHIP_NO_ERROR)
    {
        switch (TLV::TagNumFromTag(aReader.GetTag()))
        {
        case 0:
            VerifyOrExit(aReader.GetType() == TLV::TLVType::kTLVType_ByteString, err = CHIP_ERROR_WRONG_TLV_TYPE);
            ssidLen = aReader.GetLength();
            SuccessOrExit(err = aReader.GetDataPtr(ssid));
            break;
        case 1:
            VerifyOrExit(aReader.GetType() == TLV::TLVType::kTLVType_ByteString, err = CHIP_ERROR_WRONG_TLV_TYPE);
            credentialsLen = aReader.GetLength();
            SuccessOrExit(err = aReader.GetDataPtr(credentials));
            break;
        case 2:
            VerifyOrExit(aReader.GetType() == TLV::TLVType::kTLVType_UnsignedInteger, err = CHIP_ERROR_WRONG_TLV_TYPE);
            SuccessOrExit(err = aReader.Get(breadcrumb));
            break;
        case 3:
            VerifyOrExit(aReader.GetType() == TLV::TLVType::kTLVType_UnsignedInteger, err = CHIP_ERROR_WRONG_TLV_TYPE);
            SuccessOrExit(err = aReader.Get(timeoutMs));
            break;
        default:
            err = CHIP_ERROR_UNKNOWN_IMPLICIT_TLV_TAG;
            break;
        }
        SuccessOrExit(err);
    }

    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
exit:
    if (err != CHIP_NO_ERROR)
    {
        return err;
    }
    HandleAddWiFiNetworkCommandReceived(apCommandObj, aEndPointId, ssid, ssidLen, credentials, credentialsLen, breadcrumb,
                                        timeoutMs);
    return CHIP_NO_ERROR;
}

CHIP_ERROR ProcessServerSideAddThreadNetworkCommand(chip::EndpointId aEndPointId, chip::TLV::TLVReader & aReader,
                                                    Command * apCommandObj)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    const uint8_t * operationalDataset;
    uint32_t operationalDatasetLen;
    uint64_t breadcrumb;
    uint32_t timeoutMs;

    while ((err = aReader.Next()) == CHIP_NO_ERROR)
    {
        uint64_t tag = aReader.GetTag();
        TLV::TLVType elementType;
        switch (TLV::TagNumFromTag(tag))
        {
        case 0:
            elementType = aReader.GetType();
            VerifyOrExit(elementType == TLV::TLVType::kTLVType_ByteString, err = CHIP_ERROR_WRONG_TLV_TYPE);
            operationalDatasetLen = aReader.GetLength();
            SuccessOrExit(aReader.GetDataPtr(operationalDataset));
            break;
        case 1:
            VerifyOrExit(aReader.GetType() == TLV::TLVType::kTLVType_UnsignedInteger, err = CHIP_ERROR_WRONG_TLV_TYPE);
            SuccessOrExit(err = aReader.Get(breadcrumb));
            break;
        case 2:
            VerifyOrExit(aReader.GetType() == TLV::TLVType::kTLVType_UnsignedInteger, err = CHIP_ERROR_WRONG_TLV_TYPE);
            SuccessOrExit(err = aReader.Get(timeoutMs));
            break;
        default:
            err = CHIP_ERROR_UNKNOWN_IMPLICIT_TLV_TAG;
            break;
        }
        SuccessOrExit(err);
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
exit:
    if (err != CHIP_NO_ERROR)
    {
        return err;
    }
    HandleAddThreadNetworkCommandReceived(apCommandObj, aEndPointId, operationalDataset, operationalDatasetLen, breadcrumb,
                                          timeoutMs);
    return CHIP_NO_ERROR;
}

CHIP_ERROR ProcessServerSideEnableNetworkCommand(chip::EndpointId aEndPointId, chip::TLV::TLVReader & aReader,
                                                 Command * apCommandObj)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    const uint8_t * networkId;
    uint32_t networkIdLen;
    uint64_t breadcrumb;
    uint32_t timeoutMs;

    while ((err = aReader.Next()) == CHIP_NO_ERROR)
    {
        switch (TLV::TagNumFromTag(aReader.GetTag()))
        {
        case 0:
            VerifyOrExit(aReader.GetType() == TLV::TLVType::kTLVType_ByteString, err = CHIP_ERROR_WRONG_TLV_TYPE);
            networkIdLen = aReader.GetLength();
            SuccessOrExit(err = aReader.GetDataPtr(networkId));
            break;
        case 1:
            VerifyOrExit(aReader.GetType() == TLV::TLVType::kTLVType_UnsignedInteger, err = CHIP_ERROR_WRONG_TLV_TYPE);
            SuccessOrExit(err = aReader.Get(breadcrumb));
            break;
        case 2:
            VerifyOrExit(aReader.GetType() == TLV::TLVType::kTLVType_UnsignedInteger, err = CHIP_ERROR_WRONG_TLV_TYPE);
            SuccessOrExit(err = aReader.Get(timeoutMs));
            break;
        default:
            err = CHIP_ERROR_UNKNOWN_IMPLICIT_TLV_TAG;
            break;
        }
        SuccessOrExit(err);
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
exit:
    HandleEnableNetworkCommandReceived(apCommandObj, aEndPointId, networkId, networkIdLen, breadcrumb, timeoutMs);
    return CHIP_NO_ERROR;
}

CHIP_ERROR DispatchServerSideCommand(chip::CommandId aCommandId, chip::EndpointId aEndPointId, chip::TLV::TLVReader & aReader,
                                     Command * apCommandObj)
{
    switch (aCommandId)
    {
    case ZCL_ADD_WI_FI_NETWORK_COMMAND_ID:
        return ProcessServerSideAddWiFiNetworkCommand(aEndPointId, aReader, apCommandObj);
    case ZCL_ADD_THREAD_NETWORK_COMMAND_ID:
        return ProcessServerSideAddThreadNetworkCommand(aEndPointId, aReader, apCommandObj);
    case ZCL_ENABLE_NETWORK_COMMAND_ID:
        return ProcessServerSideEnableNetworkCommand(aEndPointId, aReader, apCommandObj);
    default:
        return CHIP_ERROR_KEY_NOT_FOUND;
    }
}

} // namespace NetworkProvisioning
} // namespace cluster

void DispatchSingleClusterCommand(chip::ClusterId aClusterId, chip::CommandId aCommandId, chip::EndpointId aEndPointId,
                                  chip::TLV::TLVReader & aReader, Command * apCommandObj)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    TLV::TLVType outerContainerType;

    SuccessOrExit(err = aReader.EnterContainer(outerContainerType));

    switch (aClusterId)
    {
    case ZCL_NWPROV_CLUSTER_ID:
        err = chip::app::cluster::NetworkProvisioning::DispatchServerSideCommand(aCommandId, aEndPointId, aReader, apCommandObj);
        break;
    default:;
    }

    ChipLogFunctError(err);

    SuccessOrExit(err = aReader.ExitContainer(outerContainerType));
exit:;
}

void linkLineMine() {}

} // namespace app
} // namespace chip
