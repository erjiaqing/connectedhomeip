#include "im-command-handler.h"

#include <core/CHIPCore.h>
#include <core/CHIPError.h>

// TODO: This file shoule be generated by ZAP

namespace chip {
namespace app {
namespace cluster {
namespace NetworkProvisioning {

CHIP_ERROR ProcessServerSideAddWiFiNetworkCommand(chip::EndpointId aEndPointId, chip::GroupId aGroupId,
                                                  chip::TLV::TLVReader & aReader, Command * apCommandObj)
{}

CHIP_ERROR ProcessServerSideAddThreadNetworkCommand(chip::EndpointId aEndPointId, chip::GroupId aGroupId,
                                                    chip::TLV::TLVReader & aReader, Command * apCommandObj)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    const uint8_t * operationalDataset;
    uint32_t operationalDatasetLen;

    while ((err = aReader.Next()) == CHIP_NO_ERROR)
    {
        uint64_t tag = aReader.GetTag();
        TLV::TLVType elementType;
        switch (TLV::TagNumFromTag(tag))
        {
        case 0:
            elementType = aReader.GetType();
            VerifyOrExit(elementType == TLV::TLVType::kTLVType_ByteString, err = CHIP_ERROR_WRONG_TLV_TYPE);
            operationalDatasetLen = aReader.GetLength();
            VerifyOrExit(operationalDatasetLen <= sizeof(operationalDataset), err = CHIP_ERROR_MESSAGE_TOO_LONG);
            SuccessOrExit(aReader.GetDataPtr(operationalDataset));
            break;
        case 1:
        case 2:
            break;
        default:
            err = CHIP_ERROR_UNKNOWN_IMPLICIT_TLV_TAG;
            break;
        }
        SuccessOrExit(err);
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
exit:
    if (err != CHIP_NO_ERROR)
    {
        return err;
    }
    return HandleAddThreadNetworkCommandReceived(apCommandObj, aEndPointId, operationalDataset, operationalDatasetLen);
}

CHIP_ERROR ProcessServerSideEnableNetworkCommand(chip::EndpointId aEndPointId, chip::GroupId aGroupId,
                                                 chip::TLV::TLVReader & aReader, Command * apCommandObj)
{}

CHIP_ERROR DispatchServerSideCommand(chip::CommandId aCommandId, chip::EndpointId aEndPointId, chip::GroupId aGroupId,
                                     chip::TLV::TLVReader & aReader, Command * apCommandObj)
{
    switch (aCommandId)
    {
    case ZCL_ADD_WI_FI_NETWORK_COMMAND_ID:
        return ProcessServerSideAddWiFiNetworkCommand(aEndPointId, aGroupId, aReader, apCommandObj);
    case ZCL_ADD_THREAD_NETWORK_COMMAND_ID:
        return ProcessServerSideAddThreadNetworkCommand(aEndPointId, aGroupId, aReader, apCommandObj);
    case ZCL_ENABLE_NETWORK_COMMAND_ID:
        return ProcessServerSideEnableNetworkCommand(aEndPointId, aGroupId, aReader, apCommandObj);
    default:
        return CHIP_ERROR_KEY_NOTFOUND;
    }
}

} // namespace NetworkProvisioning
} // namespace cluster

void DispatchSingleClusterCommand(chip::ClusterId aClusterId, chip::CommandId aCommandId, chip::EndpointId aEndPointId,
                                  chip::GroupId aGroupId, chip::TLV::TLVReader & aReader, Command * apCommandObj)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    TLV::TLVType outerContainerType;

    SuccessOrExit(err = aReader.EnterContainer(outerContainerType));

    switch (aClusterId)
    {
    case ZCL_NWPROV_CLUSTER_ID:
        err = chip::app::cluster::NetworkProvisioning::DispatchServerSideCommand(aCommandId, aEndPointId, aGroupId, aReader,
                                                                                 apCommandObj);
        break;
    default:
    }

    SuccessOrExit(err = aReader.ExitContainer(outerContainerType));
exit:
}

} // namespace app
} // namespace chip
